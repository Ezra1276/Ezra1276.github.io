<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vermont Flood Closures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 20px;
      background: #f5f7fa;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    #mapContainer {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 1000;
      background: white;
      flex-direction: column;
    }

    #mapControls {
      position: relative;
      padding: 10px;
      background: #f9f9f9;
      border-bottom: 1px solid #ccc;
      z-index: 1100;
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }

    #mapBackToSiteBtn {
      padding: 10px 15px;
      background: #ff4c4c;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
    }
    #mapBackToSiteBtn:hover {
      background: #e04040;
    }

    #map {
      flex-grow: 1;
      width: 100%;
    }

    #contentContainer {
      max-width: 1200px;
      margin: 0 auto;
    }

    input[type="text"], input[type="datetime-local"], input[type="file"], select {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      margin-top: 4px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 14px;
      transition: border-color 0.3s ease;
    }
    input[type="text"]:focus, input[type="datetime-local"]:focus, select:focus {
      border-color: #4a90e2;
      outline: none;
    }

    #searchTown, #searchRoad {
      font-size: 16px;
      padding: 10px;
      margin-bottom: 10px;
      width: 100%;
      box-sizing: border-box;
      border-radius: 5px;
      border: 1px solid #ccc;
      transition: border-color 0.3s ease;
    }
    #searchTown:focus, #searchRoad:focus {
      border-color: #4a90e2;
      outline: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      table-layout: fixed;
      word-wrap: break-word;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    th, td {
      padding: 10px 8px;
      text-align: left;
      vertical-align: middle;
      border-bottom: 1px solid #e1e4e8;
      font-size: 14px;
    }

    th {
      background-color: #f0f2f5;
      font-weight: 600;
      white-space: nowrap;
    }

    img {
      max-width: 100px;
      height: auto;
      display: block;
      margin-bottom: 6px;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    }

    button {
      padding: 6px 10px;
      margin: 3px 3px 3px 0;
      cursor: pointer;
      font-size: 14px;
      border: none;
      border-radius: 5px;
      transition: background-color 0.25s ease;
      user-select: none;
    }

    button.submit-btn {
      background-color: #4CAF50;
      color: white;
    }
    button.submit-btn:hover:not(:disabled) {
      background-color: #45a049;
    }
    button.submit-btn:disabled {
      background-color: #a5d6a7;
      cursor: not-allowed;
    }

    button.delete-btn {
      background-color: #f44336;
      color: white;
    }
    button.delete-btn:hover {
      background-color: #d32f2f;
    }

    button.map-button {
      background: transparent;
      font-size: 18px;
      padding: 0 6px;
      margin-left: 6px;
      line-height: 1;
    }
    button.map-button:hover {
      color: #4a90e2;
    }

    .road-cell {
      display: flex;
      align-items: center;
    }
    .road-cell input[type="text"] {
      flex-grow: 1;
      margin: 0;
    }

    .actions-container {
      white-space: nowrap;
    }

    /* Spinner */
    .spinner {
      border: 2px solid #f3f3f3;
      border-top: 2px solid #555;
      border-radius: 50%;
      width: 14px;
      height: 14px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-left: 6px;
      position: relative;
      top: -1px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }

    /* Error highlight */
    .error {
      border-color: #e53935 !important;
      box-shadow: 0 0 4px #e53935;
    }

    /* Responsive for mobile */
    @media (max-width: 768px) {
      table, thead, tbody, th, td, tr {
        display: block;
      }
      thead tr {
        position: absolute;
        top: -9999px;
        left: -9999px;
      }
      tr {
        margin-bottom: 15px;
        background: white;
        padding: 12px 10px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      }
      td {
        position: relative;
        padding-left: 45%;
        text-align: left;
        font-size: 13px;
        word-break: break-word;
      }
      td::before {
        position: absolute;
        top: 12px;
        left: 12px;
        width: 40%;
        padding-right: 10px;
        white-space: nowrap;
        font-weight: 700;
        color: #555;
        content: attr(data-label);
      }
      .road-cell {
        flex-direction: column;
        align-items: flex-start;
      }
      .road-cell input[type="text"] {
        width: 100% !important;
        margin-bottom: 6px;
      }
      button.map-button {
        padding: 0;
        font-size: 24px;
        margin-left: 0;
      }
      .actions-container button {
        width: 48%;
        margin-bottom: 6px;
      }
      .actions-container {
        white-space: normal;
      }
    }

  </style>
</head>
<body>

<h1>Vermont Road Closures</h1>

<div style="text-align:center; margin-bottom: 15px;">
  <button id="openMapBtn">ðŸ—º View Fullscreen Map</button>
</div>

<div id="mapContainer">
  <div id="mapControls">
    <button id="mapBackToSiteBtn">â¬… Back to Site</button>
  </div>
  <div id="map"></div>
</div>

<div id="contentContainer">
  <input type="text" id="searchTown" placeholder="Search by town name..." autocomplete="off" />
  <input type="text" id="searchRoad" placeholder="Search by road name..." autocomplete="off" />

  <table>
    <thead>
      <tr>
        <th>Town Name</th>
        <th>Road Name</th>
        <th>Image</th>
        <th>Time Reported</th>
        <th>Reported By</th>
        <th>Status</th>
        <th>Notes</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="tableBody"></tbody>
  </table>

  <button id="addRowBtn" style="margin-top: 15px; padding: 10px 16px; font-size: 16px;">âž• Add New Row</button>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
  // Firebase config & init
  const firebaseConfig = {
    apiKey: "AIzaSyBEWfWRM6MohRwkGe_tGjCg9D_xwpRE-XU",
    authDomain: "flood-closures.firebaseapp.com",
    databaseURL: "https://flood-closures-default-rtdb.firebaseio.com",
    projectId: "flood-closures",
    storageBucket: "flood-closures.firebasestorage.app",
    messagingSenderId: "258849178608",
    appId: "1:258849178608:web:367e2bd0cc96103b845335"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // imgbb API key for image uploads
  const IMGBB_API_KEY = 'dbc72d2ce36090fd55be72eac5cc5147';

  // DOM elements
  const tableBody = document.getElementById('tableBody');
  const contentContainer = document.getElementById('contentContainer');
  const mapContainer = document.getElementById('mapContainer');
  const openMapBtn = document.getElementById('openMapBtn');
  const mapBackBtn = document.getElementById('mapBackToSiteBtn');
  const searchTown = document.getElementById('searchTown');
  const searchRoad = document.getElementById('searchRoad');

  // Leaflet map init
  const map = L.map('map').setView([44.0, -72.7], 8);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

  // Status options & their marker colors
  const statusOptions = [
    { value: 'passable', label: 'Passable', color: 'green' },
    { value: 'washed_out', label: 'Slightly Washed Out', color: 'yellow' },
    { value: 'impassable', label: 'Impassable', color: 'red' },
    { value: 'unknown', label: 'Unknown', color: 'gray' }
  ];

  // Store markers keyed by row id
  const markers = new Map();

  // Utility to sanitize inputs (basic)
  function sanitize(str) {
    return String(str).trim();
  }

  // Upload image to imgbb
  async function uploadToImgBB(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
          method: 'POST',
          body: new URLSearchParams({ image: base64 })
        })
          .then(res => res.json())
          .then(data => data.success ? resolve(data.data.url) : reject('Upload failed'))
          .catch(reject);
      };
      reader.readAsDataURL(file);
    });
  }

  // Geocode an address (town + road) with caching
  const geocache = new Map();
  async function geocodeAddress(town, road) {
    const query = `${road}, ${town}, Vermont`;
    if (geocache.has(query)) {
      return geocache.get(query);
    }
    try {
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
      const data = await res.json();
      if (data.length > 0) {
        const latLng = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        geocache.set(query, latLng);
        return latLng;
      }
    } catch (e) {
      console.warn('Geocoding failed for:', query);
    }
    return null;
  }

  // Create custom colored marker icon
  function coloredMarker(color) {
    const iconUrl = {
      green: "https://maps.google.com/mapfiles/ms/icons/green-dot.png",
      yellow: "https://maps.google.com/mapfiles/ms/icons/yellow-dot.png",
      red: "https://maps.google.com/mapfiles/ms/icons/red-dot.png",
      gray: "https://maps.google.com/mapfiles/ms/icons/gray-dot.png"
    }[color] || "https://maps.google.com/mapfiles/ms/icons/gray-dot.png";

    return L.icon({
      iconUrl,
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
  }

  // Create or update a marker for a closure
  async function createOrUpdateMarker(rowId, data) {
    if (!data.town || !data.road) return;

    const latLng = await geocodeAddress(data.town, data.road);
    if (!latLng) return;

    // Remove existing marker if any
    if (markers.has(rowId)) {
      map.removeLayer(markers.get(rowId));
      markers.delete(rowId);
    }

    // Create marker with appropriate color
    const statusObj = statusOptions.find(s => s.value === data.status) || statusOptions[3];
    const marker = L.marker(latLng, { icon: coloredMarker(statusObj.color) });

    // Popup content with image and info
    let popupHtml = `<strong>${data.town} - ${data.road}</strong><br>`;
    popupHtml += `<em>Status: ${statusObj.label}</em><br>`;
    if (data.imageUrl) {
      popupHtml += `<img src="${data.imageUrl}" alt="Closure Image" style="max-width:150px; margin-top:5px; border-radius:6px;">`;
    }
    if (data.notes) {
      popupHtml += `<br><small>Notes: ${sanitize(data.notes)}</small>`;
    }
    marker.bindPopup(popupHtml);

    marker.addTo(map);
    markers.set(rowId, marker);
  }

  // Get ISO string for datetime-local default
  function getCurrentDatetimeLocal() {
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    return now.toISOString().slice(0, 16);
  }

  // Autocomplete helper (simple client side)
  function autocomplete(input, list) {
    let currentFocus;

    input.addEventListener("input", function() {
      let val = this.value;
      closeAllLists();
      if (!val) return false;
      currentFocus = -1;

      const divList = document.createElement("DIV");
      divList.setAttribute("class", "autocomplete-items");
      divList.style.border = "1px solid #d4d4d4";
      divList.style.borderTop = "none";
      divList.style.position = "absolute";
      divList.style.backgroundColor = "#fff";
      divList.style.zIndex = "99";
      divList.style.maxHeight = "150px";
      divList.style.overflowY = "auto";
      this.parentNode.appendChild(divList);

      for (let i = 0; i < list.length; i++) {
        if (list[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
          const itemDiv = document.createElement("DIV");
          itemDiv.innerHTML = "<strong>" + list[i].substr(0, val.length) + "</strong>";
          itemDiv.innerHTML += list[i].substr(val.length);
          itemDiv.innerHTML += "<input type='hidden' value='" + list[i] + "'>";
          itemDiv.style.padding = "6px";
          itemDiv.style.cursor = "pointer";

          itemDiv.addEventListener("click", function() {
            input.value = this.getElementsByTagName("input")[0].value;
            closeAllLists();
            input.dispatchEvent(new Event('input')); // trigger input event to update filtering if needed
          });
          divList.appendChild(itemDiv);
        }
      }
    });

    input.addEventListener("keydown", function(e) {
      const x = this.parentNode.querySelector(".autocomplete-items");
      if (!x) return;
      let items = x.getElementsByTagName("div");
      if (e.keyCode == 40) { // down
        currentFocus++;
        addActive(items);
      } else if (e.keyCode == 38) { // up
        currentFocus--;
        addActive(items);
      } else if (e.keyCode == 13) { // enter
        e.preventDefault();
        if (currentFocus > -1) {
          if (items) items[currentFocus].click();
        }
      }
    });

    function addActive(items) {
      if (!items) return false;
      removeActive(items);
      if (currentFocus >= items.length) currentFocus = 0;
      if (currentFocus < 0) currentFocus = items.length -1;
      items[currentFocus].classList.add("autocomplete-active");
      items[currentFocus].style.backgroundColor = "#e9e9e9";
    }
    function removeActive(items) {
      for (let i=0; i < items.length; i++) {
        items[i].classList.remove("autocomplete-active");
        items[i].style.backgroundColor = "";
      }
    }
    function closeAllLists(elmnt) {
      const items = document.querySelectorAll(".autocomplete-items");
      for (let i=0; i < items.length; i++) {
        if (elmnt != items[i] && elmnt != input) {
          items[i].parentNode.removeChild(items[i]);
        }
      }
    }
    document.addEventListener("click", function(e) {
      closeAllLists(e.target);
    });
  }

  // Global arrays for autocomplete options (populate dynamically)
  let townList = [];
  let roadList = [];

  // Create or update a row in the table
  function createRow(rowId, rowData = {}) {
    // Avoid duplicate rows
    if (document.querySelector(`tr[data-firebase-key="${rowId}"]`)) return;

    const tr = document.createElement('tr');
    tr.dataset.firebaseKey = rowId;

    // Town input
    const townInput = document.createElement('input');
    townInput.type = 'text';
    townInput.value = rowData.town || '';
    townInput.autocomplete = 'off';

    // Road input + map button container
    const roadContainer = document.createElement('div');
    roadContainer.classList.add('road-cell');

    const roadInput = document.createElement('input');
    roadInput.type = 'text';
    roadInput.value = rowData.road || '';
    roadInput.autocomplete = 'off';

    const mapBtn = document.createElement('button');
    mapBtn.classList.add('map-button');
    mapBtn.title = 'Go to Map Marker';
    mapBtn.textContent = 'ðŸ—º';
    mapBtn.onclick = async () => {
      // Zoom and center map to this marker
      const marker = markers.get(rowId);
      if (marker) {
        openMapBtn.click(); // open map container
        setTimeout(() => {
          map.setView(marker.getLatLng(), 14, { animate: true });
          marker.openPopup();
        }, 300);
      } else {
        alert('Marker not found or location not geocoded yet.');
      }
    };

    roadContainer.appendChild(roadInput);
    roadContainer.appendChild(mapBtn);

    // Image & file input container
    const image = document.createElement('img');
    image.src = rowData.imageUrl || 'https://via.placeholder.com/150?text=No+Image';
    image.alt = "Closure Image";

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.marginTop = '6px';
    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (file) image.src = URL.createObjectURL(file);
    });

    // Time input
    const timeInput = document.createElement('input');
    timeInput.type = 'datetime-local';
    timeInput.value = rowData.time || getCurrentDatetimeLocal();

    // Reporter input
    const reporterInput = document.createElement('input');
    reporterInput.type = 'text';
    reporterInput.value = rowData.reporter || '';

    // Status select input
    const statusSelect = document.createElement('select');
    statusOptions.forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.label;
      if (rowData.status === opt.value) option.selected = true;
      statusSelect.appendChild(option);
    });

    // Notes input
    const notesInput = document.createElement('input');
    notesInput.type = 'text';
    notesInput.value = rowData.notes || '';

    // Buttons container
    const actionsTd = document.createElement('td');
    actionsTd.classList.add('actions-container');

    const submitBtn = document.createElement('button');
    submitBtn.classList.add('submit-btn');
    submitBtn.textContent = rowData.submitted ? 'Update' : 'Submit';

    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = 'Delete';

    // Submit button click handler
    submitBtn.onclick = async () => {
      // Clear previous errors
      [townInput, roadInput, timeInput, reporterInput].forEach(el => el.classList.remove('error'));

      // Validate required fields
      const requiredFields = [townInput, roadInput, timeInput, reporterInput];
      if (requiredFields.some(el => !el.value.trim())) {
        requiredFields.forEach(el => { if (!el.value.trim()) el.classList.add('error'); });
        alert("Please fill out all required fields.");
        return;
      }

      submitBtn.disabled = true;
      submitBtn.textContent = 'Saving ';
      const spinner = document.createElement('span');
      spinner.className = 'spinner';
      submitBtn.appendChild(spinner);

      // Handle image upload if a new file is selected
      let imageUrl = rowData.imageUrl || '';
      if (fileInput.files.length > 0) {
        try {
          imageUrl = await uploadToImgBB(fileInput.files[0]);
        } catch (e) {
          alert("Image upload failed.");
          submitBtn.textContent = rowData.submitted ? 'Update' : 'Submit';
          submitBtn.disabled = false;
          return;
        }
      }

      // Save data to Firebase
      const newData = {
        town: sanitize(townInput.value),
        road: sanitize(roadInput.value),
        imageUrl,
        time: timeInput.value,
        reporter: sanitize(reporterInput.value),
        notes: sanitize(notesInput.value),
        status: statusSelect.value,
        submitted: true
      };

      await db.ref('rows/' + rowId).set(newData);

      // Update autocomplete lists dynamically
      if (!townList.includes(newData.town)) townList.push(newData.town);
      if (!roadList.includes(newData.road)) roadList.push(newData.road);

      // Update marker on map
      await createOrUpdateMarker(rowId, newData);

      submitBtn.textContent = 'Update';
      submitBtn.disabled = false;
      alert('Saved successfully!');
    };

    // Delete button handler
    deleteBtn.onclick = async () => {
      if (!confirm("Are you sure you want to delete this entry?")) return;
      await db.ref('rows/' + rowId).remove();
      if (markers.has(rowId)) {
        map.removeLayer(markers.get(rowId));
        markers.delete(rowId);
      }
      tr.remove();
    };

    // Append inputs to table cells
    function createTd(...children) {
      const td = document.createElement('td');
      children.forEach(c => td.appendChild(c));
      return td;
    }

    tr.appendChild(createTd(townInput));
    tr.appendChild(createTd(roadContainer));
    tr.appendChild(createTd(image, fileInput));
    tr.appendChild(createTd(timeInput));
    tr.appendChild(createTd(reporterInput));
    tr.appendChild(createTd(statusSelect));
    tr.appendChild(createTd(notesInput));
    actionsTd.appendChild(submitBtn);
    actionsTd.appendChild(deleteBtn);
    tr.appendChild(actionsTd);

    tableBody.appendChild(tr);

    // Initialize autocomplete on new inputs
    autocomplete(townInput, townList);
    autocomplete(roadInput, roadList);
  }

  // Firebase listeners for realtime updates
  db.ref('rows').on('child_added', snapshot => {
    const data = snapshot.val();
    data.submitted = true;
    createRow(snapshot.key, data);

    if (data.town && data.road) createOrUpdateMarker(snapshot.key, data);

    // Update autocomplete options
    if (data.town && !townList.includes(data.town)) townList.push(data.town);
    if (data.road && !roadList.includes(data.road)) roadList.push(data.road);
  });

  db.ref('rows').on('child_changed', snapshot => {
    const data = snapshot.val();
    const rowId = snapshot.key;

    // Remove old row and marker then re-create
    const existingRow = document.querySelector(`tr[data-firebase-key="${rowId}"]`);
    if (existingRow) existingRow.remove();

    createRow(rowId, data);
    createOrUpdateMarker(rowId, data);

    // Update autocomplete
    if (data.town && !townList.includes(data.town)) townList.push(data.town);
    if (data.road && !roadList.includes(data.road)) roadList.push(data.road);
  });

  db.ref('rows').on('child_removed', snapshot => {
    const rowId = snapshot.key;
    const existingRow = document.querySelector(`tr[data-firebase-key="${rowId}"]`);
    if (existingRow) existingRow.remove();
    if (markers.has(rowId)) {
      map.removeLayer(markers.get(rowId));
      markers.delete(rowId);
    }
  });

  // Add new row button
  document.getElementById('addRowBtn').onclick = () => {
    const newRef = db.ref('rows').push();
    createRow(newRef.key);
  };

  // Filter rows based on search inputs
  function filterRows() {
    const townFilter = searchTown.value.toLowerCase();
    const roadFilter = searchRoad.value.toLowerCase();

    Array.from(tableBody.children).forEach(row => {
      const townInput = row.querySelector('td:nth-child(1) input');
      const roadInput = row.querySelector('td:nth-child(2) input');

      const townVal = townInput ? townInput.value.toLowerCase() : '';
      const roadVal = roadInput ? roadInput.value.toLowerCase() : '';

      if (townVal.includes(townFilter) && roadVal.includes(roadFilter)) {
        row.style.display = '';
      } else {
        row.style.display = 'none';
      }
    });
  }

  searchTown.addEventListener('input', filterRows);
  searchRoad.addEventListener('input', filterRows);

  // Open fullscreen map
  openMapBtn.onclick = () => {
    contentContainer.style.display = 'none';
    mapContainer.style.display = 'flex';
    setTimeout(() => map.invalidateSize(), 200);
    map.setView([44.0, -72.7], 8);
  };

  // Back to content from map
  mapBackBtn.onclick = () => {
    mapContainer.style.display = 'none';
    contentContainer.style.display = 'block';
  };

</script>

</body>
</html>
